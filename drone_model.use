model DroneDeliveryModel

-- enumeration for states
enum Drone_State {Charged, Delivering, Discharged, Returning}
enum Receptacle_State {Free, Occupied}
enum Command_State {Created, Assigned, Delivered}

class Drone
	attributes
		capacity : Integer init = 0
		energy : Integer init = 3

	operations

		distancePoint(p:Point) : Integer = (self.position_drone.x - p.x).abs + (self.position_drone.y - p.y).abs;

		recharge ()
			begin
				self.energy := self.energy + 1;
				-- TODO test if energy <3 and maybe incremente time
			end
		move (newX : Integer, newY : Integer) -- ?? deplacement vers un Point ou comme pour l'instant, ie deplacer d'un x et d'un y
		begin
			declare point : Point;
			point := Point.allInstances().select(point | point.x = self.position_drone.x + newX and point.y = self.position_drone.y + newY)->asSequence()->first();
			delete (self.position_drone, self) from Position; 
			insert (point, self) into Position;
			self.energy := self.energy -1;
			
		end
		deliver()
			begin
				declare recep : Set(Receptacle);
				-- fill current receptacle 
				recep := Receptacle.allInstances().select( rec | rec.distanceDrone(self) = 0);
				for r in recep do
					r.capacity := r.capacity + self.capacity;
				end;

				self.capacity := 0;
				delete (self.receptacle, self) from Delivery;
			end

end

class Point 
	attributes 
		x : Integer
		y : Integer	
	operations
		-- Manhattan distance between two points 
		distance(dest : Point ) : Integer =
			(self.x - dest.x).abs + (self.y - dest.y).abs

		-- check if there is a receptacle or a warehouse in the current point
		
end

class Warehouse < Point end


class Receptacle < Point
    attributes
        capacity : Integer init = 0
        state : Receptacle_State init = Receptacle_State::Free

    operations 
    	-- All neighbours 
        neighbours() : Set(Receptacle) =
            Receptacle.allInstances() -> select (n | distance(n) < 3)

        -- Neighbours
        neighboursClosure() : Set(Receptacle) =
            self.neighbours() -> closure (r|r.neighbours())

        -- Set receptacles' states
        setFree()
			begin
				self.state := Receptacle_State::Free;
			end
        setOccupied()
	    	begin
	    		self.state := Receptacle_State::Occupied;
			end

		-- Get distance from given drone
		distanceDrone(d : Drone) : Integer =
            (self.x-d.position_drone.x).abs + (self.y-d.position_drone.y).abs
		
end

class Command
	attributes
		state : Command_State init = Command_State::Created

	operations
	 	assign()
		 	begin
		 		self.state := Command_State::Assigned
		 	end
	 	deliver()
		 	begin
		 		self.state := Command_State::Delivered
		 	end
end

class Grid end

association Owner between 
	Warehouse[1] role warehouse;
	Grid[1] role grid;
end

association Location between 
	Receptacle[*] role receptacles;
	Grid[1] role grid;
end

association Destination between 
	Receptacle[1] role receptacle;
	Command[1] role cmd;
end

association Position between 
	Point[1] role position_drone;
	Drone[*] role drone_position;
end

association Delivery between 
	Receptacle[1] role receptacle;
	Drone[1] role deliver;
end

association Crew between 
	Warehouse[1] role warehouse;
	Drone[*] role drones;

end



-- ####### CONSTRAINTS  ##########
constraints

-- ********** PRE AND POST CONDITIONS ************
context Drone::move(newX : Integer, newY : Integer)
	pre droneIsCharged : self.energy > 0
	pre moveToNeighbour : (newX + newY).abs = 1
	pre destinationIsFree : (Point.allInstances().select(p | p.x = self.position_drone.x + newX and p.y = self.position_drone.y + newY)->asSequence()->first().oclIsTypeOf(Warehouse)) or not Drone.allInstances -> exists(drone | drone.position_drone.x = self.position_drone.x + newX and drone.position_drone.y = self.position_drone.y + newY) 
	post locationHasChanged : (self.position_drone <> self.position_drone@pre)

context Drone::deliver()
	pre isRightReceptacle : self.receptacle.x =self.position_drone.x and self.receptacle.y = self.position_drone.y
	pre droneIsAtTheLocation : 
		Receptacle.allInstances-> one(r | r.distanceDrone(self) =0) and not Warehouse.allInstances-> exists(w | w.distance(self.position_drone) =0)
	pre droneContainsCmd : self.capacity <> 0
	post droneHasDeliveredCmd : self.capacity = 0
	post droneDoesnotMove : Receptacle.allInstances-> one(r | r.distanceDrone(self) =0) and 
		not Warehouse.allInstances-> exists (w | w.distance(self.position_drone) =0)

context Drone::recharge()
	pre droneIsNotFull: self.energy < 3
	pre locationAllowCharging: Receptacle.allInstances->exists (r | r.distanceDrone(self) =0)
	post droneDoesnotMove: Receptacle.allInstances->exists (r | r.distanceDrone(self) =0)

-- ************ INVARIANTS ***********

-- ** The Battery level is always between 3 and 0
context Drone inv batteryLevel : self.energy >= 0 and self.energy <= 3 

-- ** Every Point is Unique
context pointA, pointB:Point inv allPointAreUnique : 
	 (pointA.x = pointB.x) and 
	 (pointA.y = pointB.y)
	 implies pointA = pointB

-- ** There is no 2 or more drones at the same receptacle
context point:Point inv atMostOneDronePerReceptacle:
	if not point.oclIsTypeOf(Warehouse) then
		Drone.allInstances().select(d|d.distancePoint(point) = 0)->size() <= 1 and
		Drone.allInstances().select(d|d.distancePoint(point) = 0)->size() >= 0
	else
		Drone.allInstances().select(d|d.distancePoint(point) = 0)->size() >= 0
	endif

-- Transitive closure contains all receptacle
context recep:Receptacle inv completeClosure :
	recep.neighboursClosure()->includesAll(Receptacle.allInstances())

--context Drone inv droneHasChargeIfSimplePosition :
	--Drone.allInstances().select(d| not d.position_drone.oclIsTypeOf(Warehouse))
	--and
	--Drone.allInstances().select(d| not d.position_drone.oclIsTypeOf(Receptacle)) --and Drone.allInstances().select(d| d.energy >= 1)

-- ** Only One Warehouse in the grid
context Warehouse inv onlyOneWarehouse : Warehouse.allInstances->size=1
